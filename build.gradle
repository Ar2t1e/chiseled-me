buildscript {
    repositories {
        maven { url = 'http://files.minecraftforge.net/maven' }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.2-SNAPSHOT'
    }
}

plugins {
    id 'net.minecraftforge.gradle.forge' version '2.0.2'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '0.5'
}

version = '1.1.0'
group = 'dev.necauqua.mods'

sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8

minecraft {
    version = '1.10.2-12.18.3.2185'
    mappings = 'stable_29'
    runDir = 'build/run'
    clientRunArgs += ['--username', 'dev'] // force the same username (not each time different PlayerXXX)

    replace '@VERSION@', project.version
    replace '@MC_VERSION@', version
    replace '@API_VERSION@', '1.1'
    replace '@UPDATE_URL@', 'https://raw.githubusercontent.com/necauqua/chiseled-me/master/updates.json'
}

// fix forgegradle runs being cached lol
runClient.outputs.upToDateWhen { false }
runServer.outputs.upToDateWhen { false }

jar {
    manifest {
        attributes('FMLCorePlugin': 'dev.necauqua.mods.cm.asm.Plugin', 'FMLCorePluginContainsFMLMod': 'true')
    }
    from 'LICENSE'
}

idea {
    module {
        inheritOutputDirs = false
        outputDir = compileJava.destinationDir
        testOutputDir = compileTestJava.destinationDir
    }
}

processResources {
    inputs.property 'version', project.version
    inputs.property 'mcversion', minecraft.version
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
        expand 'version': project.version, 'mcversion': project.minecraft.version
    }
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

import net.minecraftforge.gradle.user.TaskSourceCopy

task postProcessSources {
    dependsOn += tasks.withType(TaskSourceCopy.class)
    // only apply the srg preprocessing if the final jar is going to be obfuscated
    onlyIf { project.gradle.taskGraph.hasTask(reobfJar) }
    doLast {
        def map = [:].withDefault { [] }
        genSrgs.mcpToSrg.eachLine {
            def split = it.split(' ')
            def type = split[0]
            if (type == 'MD:' || type == 'FD:') {
                def mcp = split[1]
                def srg = split[type == 'FD:' ? 2 : 3]
                def idx = mcp.lastIndexOf('/')
                def cls = mcp.substring(mcp.lastIndexOf('/', idx - 1) + 1, idx)
                def mcpName = mcp.substring(idx + 1)
                def srgName = srg.substring(srg.lastIndexOf('/') + 1)
                map[mcpName] += [srg: srgName, cls: cls, desc: type == 'MD:' ? split[4] : null]
            }
        }

        def notFound = [:]
        def ambiguous = [:]
        tasks.withType(TaskSourceCopy.class) { TaskSourceCopy tsc ->
            fileTree(tsc.output).each {
                def filename = it.name
                it.text = it.text.readLines().indexed().collect { i, line ->
                    line.replaceAll('srg\\(\\s*"(.*?)"(?:\\s*,\\s*"(.*?)")?(?:\\s*,\\s*"(.*?)")?\\s*\\)') {
                        def (mcp, cls, desc) = it[1..3]
                        def mapping = map[mcp]
                        if (cls != null) {
                            mapping = mapping.findAll { it.cls == cls }
                        }
                        if (desc != null) {
                            mapping = mapping.findAll { it.desc == desc }
                        }
                        def errorMap = mapping.size == 0 ? notFound : mapping.size != 1 ? ambiguous : null
                        if (errorMap != null) {
                            if (mcp in errorMap) {
                                errorMap[mcp][0] += 1
                            } else {
                                errorMap[mcp] = [1, "$filename:${i + 1}"]
                            }
                            return "\"$mcp\""
                        }
                        return "\"${mapping.first().srg}\""
                    }
                }.join('\n')
            }
        }
        if (!notFound.isEmpty() || !ambiguous.isEmpty()) {
            def fn = {
                def (times, file) = it.value
                "$it.key.($file)" + (times > 1 ? " (${times} times)" : '')
            }
            throw new IllegalStateException("\nProcessing SRG literals failed:\n" +
                    (!notFound.isEmpty() ? "  * Mappings not found for:\n" +
                            "    - ${notFound.collect(fn).join("\n    - ")}\n" : "") +
                    (!ambiguous.isEmpty() ? "  * Ambiguous mappings exist for:\n" +
                            "    - ${ambiguous.collect(fn).join("\n    - ")}\n" : ''))
        }
    }
}

tasks.withType(AbstractCompile) { AbstractCompile ac ->
    ac.dependsOn(postProcessSources)
}
