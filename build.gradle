buildscript {
    repositories {
        maven { url = 'http://files.minecraftforge.net/maven' }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.2-SNAPSHOT'
    }
}

plugins {
    id 'net.minecraftforge.gradle.forge' version '2.0.2'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '0.5'
}

version = '1.1.0'
group = 'dev.necauqua.mods'

sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8

minecraft {
    version = '1.10.2-12.18.3.2185'
    mappings = 'stable_29'
    runDir = 'build/run'
    clientRunArgs += ['--username', 'user']

    replace '@VERSION@', project.version
    replace '@API_VERSION@', '1.1'
    replace '@UPDATE_URL@', 'https://raw.githubusercontent.com/necauqua/chiseled-me/master/updates.json'
}

jar {
    manifest {
        attributes('FMLCorePlugin': 'dev.necauqua.mods.cm.asm.Plugin', 'FMLCorePluginContainsFMLMod': 'true')
    }
    from 'LICENSE'
}

idea {
    module {
        inheritOutputDirs = false
        outputDir = compileJava.destinationDir
        testOutputDir = compileTestJava.destinationDir
    }
}

processResources {
    inputs.property 'version', project.version
    inputs.property 'mcversion', minecraft.version
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
        expand 'version': project.version, 'mcversion': project.minecraft.version
    }
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

import net.minecraftforge.gradle.user.TaskSourceCopy

task postProcessSources {
    dependsOn += tasks.withType(TaskSourceCopy.class)
    // only apply the srg preprocessing if the final jar is going to be obfuscated
    onlyIf {
        gradle.taskGraph.hasTask(':reobfJar')
    }
    doLast {
        def map = [:].withDefault { [] }
        genSrgs.mcpToSrg.eachLine {
            if(it.startsWith('CL: ')) {
                return
            }
            def mcp, srg
            def desc = null
            if (it.startsWith('MD: ')) {
                (mcp, desc, srg) = it.split(' ')[1..3]
            } else {
                (mcp, srg) = it.split(' ')[1..2]
            }
            def idx = mcp.lastIndexOf('/')
            def cls = mcp.substring(mcp.lastIndexOf('/', idx - 1) + 1, idx)
            srg = srg.substring(srg.lastIndexOf('/') + 1)
            map.get(mcp.substring(idx + 1)).add([srg: srg, cls: cls, desc: desc])
        }
        def notFound = [:].withDefault { 0 }
        def ambiguous = [:].withDefault { 0 }
        tasks.withType(TaskSourceCopy.class) {
            fileTree(it.output).each {
                it.text = it.text.replaceAll('srg\\(\\s*"(.*?)"(?:\\s*,\\s*"(.*?)")?(?:\\s*,\\s*"(.*?)")?\\s*\\)') {
                    def (mcp, cls, desc) = it[1..3]
                    def m = map.get(mcp)
                    if (cls == null && m.size > 1) {
                        ambiguous[mcp] += 1
                        return "\"$mcp\""
                    }
                    def x = m.size == 1 ? m.get(0) : m.find { it.cls == cls && (desc == null || desc == it.desc) }
                    if (x == null) {
                        notFound[mcp] += 1
                        return "\"$mcp\""
                    }
                    return "\"$x.srg\""
                }
            }
        }
        if (!notFound.isEmpty() || !ambiguous.isEmpty()) {
            def fn = { it.getKey() + (it.getValue() > 1 ? " (${it.getValue()} times)" : '') }
            throw new IllegalStateException("\nProcessing SRG literals failed:\n" +
                    (!notFound.isEmpty() ? "  * Mappings not found for:\n" +
                            "    - ${notFound.collect(fn).join("\n    - ")}\n" : "") +
                    (!ambiguous.isEmpty() ? "  * Multiple mappings exist but class is not clarified for:\n" +
                            "    - ${ambiguous.collect(fn).join("\n    - ")}\n" : ''))
        }
    }
}

tasks.withType(AbstractCompile) {
    it.dependsOn(postProcessSources)
}
